"""Collection of admin utility functions"""
import os
import sys
import logging

from nvp.nvp_component import NVPComponent
from nvp.nvp_context import NVPContext

logger = logging.getLogger(__name__)

# Default .editorconfig content:
DEFAULT_EDITORCONFIG_CONTENT = """# Autogenerated .editorconfig file
# Update as needed.

root = true

[*]
end_of_line = lf
"""

# Default .gitignore content:
DEFAULT_GITIGNORE_CONTENT = """# Ignore python compiled files:
*.pyc

# Ignore .vs_env file:
.vs_env

# Ignore visual studio code actual settings file:
.vscode/settings.json

# Ignore log files:
*.log
"""

# Default python .env content:
DEFAULT_PYTHONENV_CONTENT = """# Autogenerated .vs_env file
# Update as needed.

PYTHONPATH=.${SEP}${NVP_ROOT_DIR}
"""

# Default nvp_config.json content:
DEFAULT_NVPCONFIG_CONTENT = """/* NVP project configuration file */
{
    // Add config entries as needed here.
}
"""

# Default nvp_plug.py content:
DEFAULT_NVPPLUG_CONTENT = '''""" NVP plug entrypoint module for ${PROJ_NAME} """

import logging

from nvp.nvp_component import NVPComponent
from nvp.nvp_context import NVPContext

logger = logging.getLogger('${PROJ_NAME}')


def register_nvp_plugin(context, proj):
    """This function should register this plugin in the current NVP context"""
    logger.info("Registering ${PROJ_NAME} NVP plugin.")
    proj.register_component('${PROJ_NAME}', MyComponent(context))


class MyComponent(NVPComponent):
    """Example component class"""

    def __init__(self, ctx: NVPContext):
        """Constructor for component"""
        NVPComponent.__init__(self, ctx)

        # define parsers and build required logic from here:
        # desc = {
        #     "build": {"libs": None},
        # }
        # ctx.define_subparsers("main", desc)
        # psr = ctx.get_parser('main.build')
        # psr.add_argument("-c", "--compiler", dest='compiler_type', type=str,
        #                  help="Specify which type of compiler should be selected")

'''

# Default .gitattributes content:
# cf. https://rehansaeed.com/gitattributes-best-practices/
###############################
# Git Large File System (LFS) #
###############################
# Could use 'filter=lfs diff=lfs merge=lfs ' below but not clear yet how to do that
# properly
DEFAULT_GITATTRIBUTES_CONTENT = """###############################
# Git Line Endings            #
###############################

# Set default behaviour to automatically normalize line endings.
* text=auto

# Force batch scripts to always use CRLF line endings so that if a repo is accessed
# in Windows via a file share from Linux, the scripts will work.
*.{cmd,[cC][mM][dD]} text eol=crlf
*.{bat,[bB][aA][tT]} text eol=crlf

# Force bash scripts to always use LF line endings so that if a repo is accessed
# in Unix via a file share from Windows, the scripts will work.
*.sh text eol=lf

# Archives
*.7z -text
*.br -text
*.gz -text
*.tar -text
*.zip -text

# Documents
*.pdf -text

# Images
*.gif -text
*.ico -text
*.jpg -text
*.pdf -text
*.png -text
*.psd -text
*.webp -text

# Fonts
*.woff2 -text

# Other
*.exe -text

"""

DEFAULT_CLI_PY_CONTENT = '''""" Main command line interface module """

import argparse

# => Adapt the code below to be your application entrypoint.

parser = argparse.ArgumentParser()
args = parser.parse_args()

print("Should implement application logic here.")

'''

DEFAULT_CLI_SH_CONTENT = '''#!/bin/bash

# cf. https://stackoverflow.com/questions/59895/how-can-i-get-the-source-directory-of-a-bash-script-from-within-the-script-itsel
ROOT_DIR=$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")" &>/dev/null && pwd)

_${PROJ_NAME}_run_cli_windows() {
    # On windows we should simply rely on the cli.bat script below:
    ROOT_DIR="$(cygpath -w $ROOT_DIR)"
    cmd /C "$ROOT_DIR\cli.bat" "$@"
}

_${PROJ_NAME}_run_cli_linux() {
    local python_version="${PY_VERSION}"

    # On linux we should call the python cli directly:
    # Get the project root folder:
    local root_dir=$(readlink -f $ROOT_DIR/)
    # echo "Project root dir is: $root_dir"

    # Check if we already have python:
    local tools_dir=$root_dir/tools/linux
    if [[ ! -d $tools_dir ]]; then
        echo "Creating tools/linux folder..."
        mkdir $tools_dir
    fi

    local python_dir=$tools_dir/python-$python_version
    local python_path=$python_dir/bin/python3

    if [[ ! -d $python_dir ]]; then
        # Get the path to package:
        local python_pkg=$root_dir/tools/packages/python-$python_version-linux.tar.xz

        echo "Extracting $python_pkg..."
        # $unzip_path x -o"$tools_dir" "$python_pkg" > /dev/null
        pushd $tools_dir >/dev/null
        tar xvJf $python_pkg
        popd >/dev/null

        # Once we have deployed the base python tool package we start with upgrading pip:
        echo "Upgrading pip..."
        $python_path -m pip install --upgrade pip

        # Finally we install the python requirements:
        echo "Installing python requirements..."
        $python_path -m pip install -r $root_dir/tools/requirements.txt
    fi

    if [ "$1" == "--install-py-reqs" ]; then
        echo "Installing python requirements..."
        $python_path -m pip install -r $root_dir/tools/requirements.txt
    elif [ "$1" == "python" ]; then
        # shift the args by one:
        shift
        $python_path "$@"
    elif [ "$1" == "pip" ]; then
        # shift the args by one:
        shift
        $python_path -m pip "$@"
    else
        # Execute the command in python:
        $python_path $root_dir/cli.py "$@"
    fi
}

${PROJ_NAME}() {
    if [ "$1" == "home" ]; then
        # We simply go to the home of this project:
        cd "$ROOT_DIR"
    else
        # Check if we are on a windows or a linux system:
        pname=$(uname -s)

        case $pname in
        CYGWIN*)
            _${PROJ_NAME}_run_cli_windows "$@"
            ;;
        *)
            _${PROJ_NAME}_run_cli_linux "$@"
            ;;
        esac
    fi
}

# cf. https://askubuntu.com/questions/141928/what-is-the-difference-between-bin-sh-and-bin-bash
(return 0 2>/dev/null) && sourced=1 || sourced=0
if [ "$sourced" == "0" ]; then
    ${PROJ_NAME} "$@"
else
    echo "${PROJ_NAME} command loaded."
fi

'''

DEFAULT_CLI_BAT_CONTENT = '''
@echo off

SETLOCAL ENABLEDELAYEDEXPANSION

@REM Retrieve the current folder:
@REM cli script is located directly in the root, so we don't need the '..' in path:
@REM cd /D %~dp0..
cd /D %~dp0
FOR /F %%i IN (".") DO set ${PROJ_NAME}_ROOT_DIR=%%~fi

set ${PROJ_NAME}_DIR=%${PROJ_NAME}_ROOT_DIR%
@REM echo Using NervProj root folder: %${PROJ_NAME}_DIR%

@REM Extract the python env if needed:
set py_vers=${PY_VERSION}
set TOOLS_DIR=%${PROJ_NAME}_DIR%\\tools\\windows\\
set UNZIP=%TOOLS_DIR%\\7zip-${ZIP_VERSION}\\7za.exe
set PYTHON=%TOOLS_DIR%\\python-%py_vers%\\python.exe

@REM Check if python is extracted already:
if not exist "%PYTHON%" (
    echo Extracting python tool...
    %UNZIP% x -o"%TOOLS_DIR%" "%${PROJ_NAME}_DIR%\\tools\\packages\\python-%py_vers%-windows.7z" > nul

    @REM Upgrade pip:
    %PYTHON% -m pip install --upgrade pip

    @REM Install requirements:
    %PYTHON% -m pip install -r %${PROJ_NAME}_DIR%\\tools\\requirements.txt
)

@REM check if the first argument is "--install-py-reqs"
IF /i "%~1" == "--install-py-reqs" goto install_reqs
IF /i "%~1" == "python" goto run_python
IF /i "%~1" == "pip" goto run_pip

%PYTHON% %NERVHOME_DIR%\cli.py %*
goto common_exit

:install_reqs
%PYTHON% -m pip install -r %NERVHOME_DIR%\tools\requirements.txt
goto common_exit

@REM cannot rely on %* when we use shift below:

:run_python
shift
%PYTHON% %1 %2 %3 %4 %5 %6 %7 %8 %9
goto common_exit

:run_pip
shift
%PYTHON% -m pip %1 %2 %3 %4 %5 %6 %7 %8 %9
goto common_exit

:common_exit

'''


def register_component(ctx: NVPContext):
    """Register this component in the given context"""
    comp = AdminManager(ctx)
    ctx.register_component('admin', comp)


class AdminManager(NVPComponent):
    """Admin command manager class"""

    def __init__(self, ctx: NVPContext):
        """Admin commands manager constructor"""
        NVPComponent.__init__(self, ctx)

        # # Check the value of the sub command:
        # sub_cmd = self.settings['l1_cmd']
        # if sub_cmd == 'install-cli':
        #     self.install_cli()

        desc = {
            "admin": {
                "install": {"cli": None, "reqs": None, "repo": None},
                "init": None,
            }
        }
        ctx.define_subparsers("main", desc)

        psr = ctx.get_parser('main.admin.init')
        psr.add_argument("-p", "--with-py-env", dest="with_py_env", action="store_true",
                         help="Request deployment of a full python environment.")

    def install_cli(self):
        """Install a CLI script in .bashrc if application"""

        # Check if an $HOME folder is provider:
        home_dir = os.getenv('HOME')
        if home_dir is None:
            logger.error("Cannot install cli alias: no $HOME environment variable detected.")
            return

        logger.info("Home folder is: %s", home_dir)

        # Check if we have a .bashrc file in that folder:
        bashrc_file = self.get_path(home_dir, ".bashrc")
        if not self.file_exists(bashrc_file):
            logger.warning("Cannot install cli alias: no .bashrc file in HOME folder.")
            return

        script_path = self.get_path(self.ctx.get_root_dir(), "cli.sh")

        # If we are on windows, we may want to convert this path to a cygwin path
        # if we are in a cygwin environment (but running the native python executable):
        if self.is_windows:
            script_path = self.to_cygwin_path(script_path)
            assert script_path is not None, "Invalid cygwin environment."

        sline = f"\n[ -f \"{script_path}\" ] && source \"{script_path}\"\n"

        # Check if this string is already in the bashrc file:
        content = self.read_text_file(bashrc_file)

        if content.find(sline) == -1:
            # We should add the string:
            logger.info("Adding source file in .bashrc for NervProj")

            # Make a backup of the file:
            self.copy_file(bashrc_file, bashrc_file+".bak", force=True)
            self.write_text_file(content+sline, bashrc_file, newline='\n')
        else:
            logger.info("NervProj setup file already referenced in .bashrc")

        # pp = pprint.PrettyPrinter(indent=2)
        # res = pp.pformat(dict(os.environ))
        # logger.info("Current environment is: %s", res)

    def install_python_requirements(self):
        """Install the requirements for the main python environment using pip"""

        logger.info("Installing python requirements...")
        reqfile = self.get_path(self.ctx.get_root_dir(), "tools/requirements.txt")
        cmd = [sys.executable, "-m", "pip", "install", "-r", reqfile]
        # logger.info("Executing command: %s", cmd)
        self.execute(cmd)
        logger.info("Done installing python requirements.")

    def install_repository_bootstrap(self):
        """Install the bootstraped repository for this NervProj folder if not present already."""

        base_dir = self.ctx.get_root_dir()
        if self.dir_exists(base_dir, ".git"):
            logger.info(".git folder already exists, bootstrapping ignored.")
            return

        # We need to bootstrap in a temp folder:
        git = self.get_component('git')

        url = self.config["repository_url"]

        dest_dir = self.get_path(base_dir, "temp", "nervproj")
        logger.info("Cloning NervProj folder into %s...", dest_dir)
        git.clone_repository(url, dest_dir)

        # When cloning is done we should move the .git folder from the clone location into our root
        self.move_path(self.get_path(dest_dir, ".git"), self.get_path(base_dir, ".git"))

        # And finally we remove the remaining files:
        self.remove_folder(dest_dir)

        logger.info("Done bootstrapping NervProj project.")

    def setup_global_vscode_config(self, config_dir=None):
        """Setup global Visual studio code user settings"""

        if config_dir is None:
            # * on windows: in C:/Users/kenshin/AppData/Roaming/Code/User/settings.json
            # => should use os.getenv('APPDATA')
            # * on linux: in /home/kenshin/.config/Code/User/settings.json
            if self.is_windows:
                base_dir = os.getenv("APPDATA")
            else:
                base_dir = self.get_path(self.ctx.get_home_dir(), ".config")

            config_dir = self.get_path(base_dir, "Code", "User")

        cfg_file = self.get_path(config_dir, "settings.json")

        config = {}
        ref_config = None

        if not self.file_exists(cfg_file):
            # Ensure the folder exists:
            self.make_folder(config_dir)
        else:
            # Read the config:
            config = self.read_json(cfg_file)
            # Keep a copy to compare the changes:
            ref_config = self.read_json(cfg_file)

        # Now write the changes we want:
        tools = self.get_component('tools')

        config["git.path"] = tools.get_git_path()
        config["python.linting.pylintEnabled"] = True
        config["python.linting.enabled"] = True
        config["python.linting.pylintPath"] = tools.get_tool_path('pylint')
        config["python.linting.pylintArgs"] = ["--max-line-length=120"]
        config["python.defaultInterpreterPath"] = tools.get_tool_path('python')
        config["python.formatting.autopep8Path"] = tools.get_tool_path("autopep8")
        config["python.formatting.provider"] = "autopep8"
        config["python.formatting.autopep8Args"] = ["--max-line-length=120", "--experimental"]
        config["editor.formatOnSave"] = True
        config["cmakeFormat.exePath"] = tools.get_tool_path("cmake_format")

        if ref_config is None or config != ref_config:
            logger.info("Wrtting updated vscode settings in %s", cfg_file)
            self.write_json(config, cfg_file)
        else:
            logger.info("No change in %s", cfg_file)

    def init_project_config(self, proj_dir, proj_name):
        """Setup initial project local config elements"""
        config_dir = self.get_path(proj_dir, ".vscode")

        cfg_file = self.get_path(config_dir, "settings.template.json")
        self.make_folder(config_dir)

        config = {}
        ref_config = None

        # Check if we should provide a python environment in this project:
        with_py = self.get_param("with_py_env", False)

        if with_py:
            logger.info("Setting up dedicated python env for %s", proj_name)

        if self.file_exists(cfg_file):
            # Read the config:
            config = self.read_json(cfg_file)
            # Keep a copy to compare the changes:
            ref_config = self.read_json(cfg_file)

        config["python.envFile"] = "${workspaceFolder}/.vs_env"

        ignore_elems = []

        if with_py:
            # We deploy the python packages:
            dest_dir = self.get_path(proj_dir, "tools", "packages")
            self.make_folder(dest_dir)
            # get the python version on windows:
            py_vers = {}
            sevenzip_vers = {}

            for plat_name in ["windows", "linux"]:
                for el in self.config[f'{plat_name}_tools']:
                    if el["name"] == 'python':
                        py_vers[plat_name] = el["version"]
                    if el["name"] == '7zip':
                        sevenzip_vers[plat_name] = el["version"]

            for plat_name, py_version in py_vers.items():
                for ext in [".7z", ".tar.xz"]:
                    file_name = f"python-{py_version}-{plat_name}{ext}"
                    src_file = self.get_path(self.ctx.get_root_dir(), "tools", "packages", file_name)
                    dst_file = self.get_path(dest_dir, file_name)
                    if self.file_exists(src_file) and not self.file_exists(dst_file):
                        logger.info("Adding package file %s", dst_file)
                        self.copy_file(src_file, dst_file)

            # more updates to vscode settings if we have a dedicated python env:
            cur_py_vers = py_vers[self.platform]

            ext = ".exe" if self.is_windows else ""

            config["python.linting.pylintEnabled"] = True
            config["python.linting.enabled"] = True
            config["python.linting.pylintPath"] = f"${{workspaceFolder}}/tools/{self.platform}/python-{cur_py_vers}/Scripts/pylint{ext}"
            config["python.linting.pylintArgs"] = ["--max-line-length=120"]
            config["python.defaultInterpreterPath"] = f"${{workspaceFolder}}/tools/{self.platform}/python-{cur_py_vers}/python{ext}"
            config["python.formatting.autopep8Path"] = f"${{workspaceFolder}}/tools/{self.platform}/python-{cur_py_vers}/Scripts/autopep8{ext}"
            config["python.formatting.provider"] = "autopep8"
            config["python.formatting.autopep8Args"] = ["--max-line-length=120", "--experimental"]

            # Next, for the windows part we need to deploy the 7zip package too:
            folder_name = f"7zip-{sevenzip_vers['windows']}"
            src_folder = self.get_path(self.ctx.get_root_dir(), "tools", "windows", folder_name)
            dst_folder = self.get_path(proj_dir, "tools", "windows", folder_name)
            if not self.dir_exists(dst_folder):
                logger.info("Adding windows 7zip package at %s", dst_folder)
                self.copy_folder(src_folder, dst_folder)

            # Update the ignore elements:
            ignore_elems += ["",
                             "# Ignore all the windows tools except the 7zip folder:",
                             "tools/windows/*",
                             "!tools/windows/7zip-*",
                             "tools/linux/*"]

            # Should also install an requirements.txt file:
            dest_file = self.get_path(proj_dir, "tools", "requirements.txt")
            if not self.file_exists(dest_file):
                logger.info("Installing pythong requirements file.")
                content = ["# List here all the required python packages",
                           "# Then call cli.{sh/bat} --install-py-reqs",
                           "",
                           "pylint",
                           "autopep8",
                           ""]
                content = "\n".join(content)
                self.write_text_file(content, dest_file)

            # Should install the cli script files:
            dest_file = self.get_path(proj_dir, "cli.py")
            if not self.file_exists(dest_file):
                logger.info("Writting cli python file %s", dest_file)
                content = DEFAULT_CLI_PY_CONTENT
                self.write_text_file(content, dest_file)

            dest_file = self.get_path(proj_dir, "cli.sh")
            if not self.file_exists(dest_file):
                logger.info("Writting cli shell file %s", dest_file)
                content = DEFAULT_CLI_SH_CONTENT
                content = content.replace("${PROJ_NAME}", proj_name.lower())
                # Use the linux python version below:
                content = content.replace("${PY_VERSION}", py_vers['linux'])
                self.write_text_file(content, dest_file, newline="\n")

            dest_file = self.get_path(proj_dir, "cli.bat")
            if not self.file_exists(dest_file):
                logger.info("Writting cli batch file %s", dest_file)
                content = DEFAULT_CLI_BAT_CONTENT
                content = content.replace("${PROJ_NAME}", proj_name.upper())
                # Use the windows versionq below:
                content = content.replace("${PY_VERSION}", py_vers['windows'])
                content = content.replace("${ZIP_VERSION}", sevenzip_vers['windows'])
                self.write_text_file(content, dest_file)

        # Finish writting the vscode config:
        if ref_config is None or config != ref_config:
            logger.info("Wrtting updated vscode settings in %s", cfg_file)
            self.write_json(config, cfg_file)
        else:
            logger.info("No change in %s", cfg_file)

        # Also copy to actuall settings if we don't have the file yet:
        cfg_file2 = self.get_path(config_dir, "settings.json")
        if not self.file_exists(cfg_file2):
            logger.info("Copyging VSCode settings template to %s", cfg_file2)
            self.copy_file(cfg_file, cfg_file2)

        # Write the env file if needed:
        dest_file = self.get_path(proj_dir, ".vs_env")
        if not self.file_exists(dest_file):
            logger.info("Writting python env file %s", dest_file)
            content = DEFAULT_PYTHONENV_CONTENT
            sep = ";" if self.is_windows else ":"
            content = content.replace("${NVP_ROOT_DIR}", "" if with_py else self.ctx.get_root_dir())
            content = content.replace("${SEP}", "" if with_py else sep)
            self.write_text_file(content, dest_file)

        # and write a .editorconfig file:
        dest_file = self.get_path(proj_dir, ".editorconfig")
        if not self.file_exists(dest_file):
            logger.info("Writting editor config file %s", dest_file)
            content = DEFAULT_EDITORCONFIG_CONTENT
            self.write_text_file(content, dest_file)

        # and write a .gitignore file:
        dest_file = self.get_path(proj_dir, ".gitignore")
        if not self.file_exists(dest_file):
            logger.info("Writting .gitignore file %s", dest_file)
            content = DEFAULT_GITIGNORE_CONTENT
            content += "\n".join(ignore_elems)
            content += "\n"
            self.write_text_file(content, dest_file)

        # and write a .gitattributes file:
        dest_file = self.get_path(proj_dir, ".gitattributes")
        if not self.file_exists(dest_file):
            logger.info("Writting .gitattributes file %s", dest_file)
            content = DEFAULT_GITATTRIBUTES_CONTENT
            self.write_text_file(content, dest_file)

        # write a nvp_config.json file:
        dest_file = self.get_path(proj_dir, "nvp_config.json")
        if not self.file_exists(dest_file):
            logger.info("Writting nvp_config.json file %s", dest_file)
            content = DEFAULT_NVPCONFIG_CONTENT
            self.write_text_file(content, dest_file)

        # write a nvp_plug.py file:
        dest_file = self.get_path(proj_dir, "nvp_plug.py")
        if not self.file_exists(dest_file):
            logger.info("Writting nvp_plug.py file %s", dest_file)
            content = DEFAULT_NVPPLUG_CONTENT.replace("${PROJ_NAME}", proj_name)
            self.write_text_file(content, dest_file)

        # Add pull rebase = false to .git/config
        cfg_file = self.get_path(proj_dir, ".git", "config")
        assert self.file_exists(cfg_file), f"Cannot fine git config file at {cfg_file}"
        # Load that config:
        config = self.read_ini(cfg_file)
        save_needed = False

        if 'pull' not in config:
            logger.info("Adding pull section in git config.")
            config['pull'] = {
                "rebase": "false",
            }
            save_needed = True
        else:
            pull = config['pull']
            if pull['rebase'] != 'false':
                logger.info("Updating git pull rebase from %s to %s", pull['rebase'], 'false')
                pull['rebase'] = 'false'
                save_needed = True

        if save_needed:
            self.write_ini(config, cfg_file)

    def process_command(self, cmd0):
        """Re-implementation of the process_command method."""

        if cmd0 != 'admin':
            return False

        cmd1 = self.ctx.get_command(1)
        cmd2 = self.ctx.get_command(2)
        if cmd1 == 'install' and cmd2 == 'cli':
            self.install_cli()
            return True

        if cmd1 == 'install' and cmd2 == 'reqs':
            self.install_python_requirements()
            return True

        if cmd1 == 'install' and cmd2 == 'repo':
            self.install_repository_bootstrap()
            return True

        if cmd1 == 'init':
            self.setup_global_vscode_config()
            proj = self.ctx.get_current_project()
            proj_dir = proj.get_root_dir() if proj is not None else self.ctx.get_root_dir()
            proj_name = proj.get_name(False) if proj is not None else "NervProj"
            self.init_project_config(proj_dir, proj_name)
            return True

        return False
